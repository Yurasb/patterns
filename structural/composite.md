# Компоновщик
**Также известен как:** Дерево

## Суть паттерна
**Компоновщик** — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

## Описание паттерна
Паттерн Компоновщик имеет смысл только тогда, когда основная модель программы может быть структурирована в виде дерева.<br>
У дерева есть "листья" - самые последние элементы структуры, у которых нет нижестоящих элементов, и "узлы" (или "контейнеры") - элементы, от которых начинаются новые ветви дерева, которые включают в себя как другие "узлы", так и "листья".<br>
Компоновщик предлогает рассматривать "узлы" и "листья" через единый интерфейс с общими методами, реализующими необходимую логику.<br>
При вызове такого метода "лист" просто выполнит логику, а "узел" делегирует её выполнение нижестоящим элементам дерева через единый интерфейс.

## Применимость
**Когда вам нужно представить древовидную структуру объектов.**<br>
Паттерн Компоновщик предлагает хранить в составных объектах ссылки на другие простые или составные объекты. Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее. В итоге вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.

**Когда клиенты должны единообразно трактовать простые и составные объекты.**<br>
Благодаря тому, что простые и составные объекты реализуют общий интерфейс, клиенту безразлично, с каким именно объектом ему предстоит работать.

## Шаги реализации
1) Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
2) Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимозаменять простые и составные компоненты без потери смысла.
3) Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько таких классов.
4) Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен с типом интерфейса компонентов.<br>
Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу своим дочерним компонентам.
5) Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.<br>
Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, это нарушит *принцип разделения интерфейса* (Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.), так как реализации методов будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут действительно одинаковыми для клиента.


## Преимущества и недостатки
**Плюсы:**
1) Упрощает архитектуру клиента при работе со сложным деревом компонентов.
2) Облегчает добавление новых видов компонентов.

**Минусы:** Создаёт слишком общий дизайн классов.