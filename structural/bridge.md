# Мост

## Суть паттерна
Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

## Описание паттерна
*Абстракция* (или *интерфейс*) — это образный слой управления чем-либо. Он не делает работу самостоятельно, а делегирует её слою *реализации* (иногда называемому *платформой*).

Если говорить о реальных программах, то абстракцией может выступать графический интерфейс программы (GUI), а реализацией — низкоуровневый код операционной системы (API), к которому графический интерфейс обращается по реакции на действия пользователя.

Можно развивать программу в двух разных направлениях:
1) иметь несколько видов GUI (например, для простых пользователей и администраторов);
2) поддерживать много видов API (например, работать под Windows, Linux и macOS).

Такая программа может выглядеть как один большой клубок кода, в котором намешаны условные операторы слоёв GUI и API.

Можно попытаться структурировать этот хаос, создав для каждой вариации интерфейса-платформы свои подклассы. Но такой подход приведёт к росту классов комбинаций, и с каждой новой платформой их будет всё больше.

Мы можем решить эту проблему, применив Мост. Паттерн предлагает распутать этот код, разделив его на две части:
* Абстракцию: слой графического интерфейса приложения.
* Реализацию: слой взаимодействия с операционной системой.

Абстракция будет делегировать работу одному из объектов реализаций. Причём, реализации можно будет взаимозаменять, но только при условии, что все они будут следовать общему интерфейсу.

Таким образом, можно изменять графический интерфейс приложения, не трогая низкоуровневый код работы с операционной системой. И наоборот, можно добавлять поддержку новых операционных систем, создавая подклассы реализации, без необходимости менять классы графического интерфейса.

## Применимость
**Когда нужно разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).**<br>
Чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к внесению случайных ошибок в код.<br>
Мост позволяет разделить монолитный класс на несколько отдельных иерархий. После этого можно менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

**Когда класс нужно расширять в двух независимых плоскостях.**<br>
Мост предлагает выделить одну из таких плоскостей в отдельную иерархию классов, храня ссылку на один из её объектов в первоначальном классе.

**Когда нужно, чтобы реализацию можно было бы изменять во время выполнения программы.**<br>
Мост позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.<br>
Кстати, из-за этого пункта Мост часто путают со Стратегией. Обратите внимание, что у Моста этот пункт стоит на последнем месте по значимости, поскольку его главная задача — структурная.

## Шаги реализации
1) Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
2) Продумайте, какие операции будут нужны клиентам, и опишите их в базовом классе абстракции.
3) Определите поведения, доступные на всех платформах, и выделите из них ту часть, которая нужна абстракции. На основании этого опишите общий интерфейс реализации.
4) Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.
5) Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу связанному объекту реализации.
6) Если есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7) Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

## Преимущества и недостатки
**Плюсы:**
1) Позволяет строить платформо-независимые программы.
2) Скрывает лишние или опасные детали реализации от клиентского кода.
3) Реализует принцип *открытости/закрытости* («программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения»).

**Минусы:** Усложняет код программы из-за введения дополнительных классов.